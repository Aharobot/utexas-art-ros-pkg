/**
 * \file  CircularImageGenerator.h
 * \brief Header for converting a PointCloud into circular images
 *
 * This class converts velodyne data into a circular image - akin to range
 * images. Although these images are application dependent, it is recommended
 * that the Overhead Image Generation code be used (which uses PointCloud2 and
 * cv::Mat)
 *
 * \author  Piyush Khandelwal (piyushk), piyushk@cs.utexas.edu
 * Copyright (C) 2011, The University of Texas at Austin, Austin Robot Technology
 *
 * License: Modified BSD License
 *
 * $ Id: 08/16/2011 02:04:00 PM piyushk $
 */

#ifndef CIRCULARIMAGEGENERATOR_XB6OIK9U
#define CIRCULARIMAGEGENERATOR_XB6OIK9U

#include <opencv/cv.h>
#include <sensor_msgs/PointCloud.h>

#include <velodyne_image_generation/CircularImageConfig.h>
#include <velodyne_image_generation/ImageRef.h>

namespace velodyne_image_generation {

  const int OUT_OF_RANGE_POINT = -3;
  const int FAILED_POINT = -2;
  const int MISSING_POINT = -1;

  /**
   * \class CircularImageGenerator
   * \brief Contains class declarations to generate circular images from velodyne data 
   */
  class CircularImageGenerator {

    private:

      CircularImageConfig config_;  ///< configuration file (used in conjunction with dynamic reconfigure)
     

      /**
       * \brief   Corrects the image for those points that have failed.
       * 
       * A failed point in the point cloud is where the laser did not return
       * a value. Since this contributes to noise in the image, we can get
       * rid of it by averaging over neighbouring pixels. This typically
       * gives a better result than gaussian blurring.
       *
       * \param   indexImage indicates whether the pixel has failed
       * \param   img contains the actual values for the image (for averaging)
       */
      void correctFailedPoints(IplImage * indexImage, IplImage * img);

    public:

      /**
       * \brief   calculates the index of the point in the point cloud
       *          corresponding to each image pixel
       */
      void calculateIndices(
          const sensor_msgs::PointCloud &pc,
          IplImage * indexImage
      );

      /**
       * \brief   obtains the intensity value from the pc and fills the img
       *          by referring the indexImage
       */
      void getIntensityImage(
          const sensor_msgs::PointCloud &pc,
          IplImage *indexImage,
          IplImage *img
      );

      /**
       * \brief   obtains the height value from the pc and fills the img
       *          by referring the indexImage
       *
       * This image is generated using a linear scale from config_.minHeight
       * and config_.maxHeight.
       */
      void getLinearHeightImage(
          const sensor_msgs::PointCloud &pc,
          IplImage *indexImage,
          IplImage *img
      );

      /**
       * \brief   obtains the height value from the pc and fills the img
       *          by referring the indexImage (contrast enhanced)
       *
       * This image is generated by magnifying a specific region of z values
       * (height) using a gaussian function. This can be viewed as a contrast
       * enhancement. Uses config_.mean and config_.sigma.
       */
      void getGaussianHeightImage(
          const sensor_msgs::PointCloud &pc,
          IplImage *indexImage,
          IplImage *img
      );

      /**
       * \brief   obtains the distance value from the pc and fills the img
       *          by referring the indexImage
       *
       * Directly maps the distance of a given point to a pixel in the image.
       * Uses a gaussian mapping to scale between the values.
       *
       */
      void getDistanceImage(
          const sensor_msgs::PointCloud &pc,
          IplImage *indexImage,
          IplImage *img
      );
      
      /**
       * \brief   Accept reconfiguration request from dynamic reconfigure
       */
      void reconfigure(CircularImageConfig newConfig) {
        config_ = newConfig;
      }

      /**
       * \brief   Returns current configuration settings
       */
      CircularImageConfig* getConfig() {
        return &config_;
      }
  };
}

#endif /* end of include guard: CIRCULARIMAGEGENERATOR_XB6OIK9U */
